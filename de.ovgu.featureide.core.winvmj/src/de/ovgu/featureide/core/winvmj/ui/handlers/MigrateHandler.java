package de.ovgu.featureide.core.winvmj.ui.handlers;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Scanner;

import org.eclipse.core.runtime.CoreException;

import DatabaseConnection.DatabaseConnection;
import DatabaseState.DatabaseState;
import DatabaseState.DatabaseStateBuilder;
import Graph.GraphNode;
import Graph.MigrationGraph;
import Loader.MigrationLoader;
import Sql.CommandList;
import Sql.MigrationExecutor;
import Sql.SqlConverter;
import de.ovgu.featureide.core.IFeatureProject;
import de.ovgu.featureide.core.winvmj.core.WinVMJProduct;
import de.ovgu.featureide.core.winvmj.core.impl.ComposedProduct;
import de.ovgu.featureide.core.winvmj.runtime.WinVMJConsole;
import de.ovgu.featureide.ui.handlers.base.AFeatureProjectHandler;

public class MigrateHandler extends AFeatureProjectHandler {

	@Override
	protected void singleAction(IFeatureProject project) {
		WinVMJConsole.showConsole();
		WinVMJConsole.println("Migrate running");
		WinVMJProduct sourceProduct;
		try {
			sourceProduct = new ComposedProduct(project);
			MigrationLoader loader = new MigrationLoader();
			String projectPath = project.getProject().getLocation().toOSString();
			String productName = sourceProduct.getProductName();
			loader.setMigrationPath(projectPath);
			loader.setproductName(productName);
			
			MigrationGraph graph = loader.loadMigrationsIntoGraph();
	        graph.resolveDependency();
	        
	        String url = WinVMJConsole.prompt("Enter DB URL:");
	        String username = WinVMJConsole.prompt("Enter DB UserName:");
	        String password = WinVMJConsole.prompt("Enter DB Password:");
	        String dbName = WinVMJConsole.prompt("Enter DB name:");
	        
	        DatabaseConnection conn = new DatabaseConnection(url, username, password, dbName);

	        ArrayList<String> appliedMigrations = getAppliedMigrationsName(conn);
	        graph.checkAppliedMigrations(appliedMigrations);
	        
	        ArrayList<GraphNode> appliedNodes = graph.getNodesByAppliedState(true);
	        ArrayList<GraphNode> unappliedNodes = graph.getNodesByAppliedState(false);
	        DatabaseStateBuilder stateBuilder = new DatabaseStateBuilder();
	        
	        DatabaseState appliedMigrationsState = stateBuilder.buildDatabaseStateFromMigrationFiles(appliedNodes);
	        SqlConverter sqlConverter = new SqlConverter();
	        sqlConverter.setSeedingPath(projectPath);
	        
	        for (GraphNode unappliedNode : unappliedNodes){
	            CommandList commandList = sqlConverter.convertGraphNodeOperationToSQL(appliedMigrationsState, unappliedNode, conn);
	            WinVMJConsole.println("====================COMMAND====================");
	            WinVMJConsole.println(commandList.toString());
	            conn.executeCreateCommand(commandList.getAllCommands()); // FIXME: Commented for testing, uncomment later
	            WinVMJConsole.println("===============COMMAND EXECUTED===============");
	            appliedMigrationsState.applyMigrationToState(unappliedNode);
	        }
		} catch (CoreException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		}

	private ArrayList<String> getAppliedMigrationsName(DatabaseConnection conn) {
		// TODO Auto-generated method stub
		ArrayList<String> appliedMigrations = new ArrayList<>();
        ResultSet queryResult = null;

        String command = "CREATE TABLE IF NOT EXISTS applied_migrations (id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name VARCHAR(255), applied_at TIMESTAMP DEFAULT NOW());";
        conn.executeCreateCommand(command);
        
        command = "SELECT name FROM applied_migrations";
        try {
            queryResult = conn.executeReadCommand(command);
            while (queryResult.next()) {
                appliedMigrations.add(queryResult.getString("name"));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return appliedMigrations;
	}
}
